---
title: mvcc分析
date: 2024-06-26 16:52:03
categories:
  - database
tags:
  - mysql
  - mvcc
  - database
---

## 前言

MVCC（Multi-Version Concurrency Control，多版本并发控制）是MySQL用于实现事务并发的机制。

## 隔离性

在分析MVCC之前，简单介绍一下事务的基本特性（ACID）：

- 原子性（Atomicity）：操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。
- 一致性（Consistency）：事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。
- 隔离性（Isolation）：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
- 持久性（Durability）：当事务正确完成后，它对于数据的改变是永久性的。

其中隔离性需要MVCC机制来实现，数据库有4个隔离级别（安全程度依次递增）：

- Read uncommitted（RU 读未提交）

一个事务可以读取另一个未提交事务的数据，会产生脏读。由定义能看出，该级别下的数据库不会引入MVCC机制，这里不做详细介绍。

- Read committed（RC 读已提交，可以避免脏读）

一个事务要等另一个事务提交后才能读取数据，会产生不可重复读。该级别下的数据库会引入MVCC机制，但与RR级别有所不同，每次读取时都会生成新的ReadView，后面做详细介绍。

- Repeatable read（RR 重复读，可避免脏读、不可重复读）

就是在开始读取数据（事务开启）时，数据保持一直，不会读取到该事务过程中其他事务已提交的新数据（产生当前读除外），会出现幻读，该级别下的数据库会引入MVCC机制，和RC级别有所不同。

- Serializable（序列化，可避免脏读、不可重复读、幻读）

Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，该级别下不会引入MVCC。

## undo log

InnoDB向存储在数据库中的每一行添加三个字段：

- DB_TRX_ID字段表示插入或更新行的最后一个事务的事务标识符。此外，删除在内部被视为更新，其中设置行中的特殊位以将其标记为已删除。
- DB_ROLL_PTR字段，称为回滚指针。回滚指针指向写入回滚段的撤消日志记录。如果行已更新，则撤消日志记录包含重建行更新前内容所需的信息。
- DB_ROW_ID字段包含行 ID，该 ID 随着新行的插入而单调增加。如果 InnoDB自动生成聚集索引，则索引包含行 ID 值。否则，该 DB_ROW_ID列不会出现在任何索引中。

MVCC的实现依赖于回滚日志，同时也是实现事务原子性（Atomicity）的一个重要机制。事务中在每次（INSERT、UPDATE、DELETE）后，会将操作前的老数据添加到undo log中，并在DB_ROLL_PTR字段中指向回滚日志中的老数据，当需要事务回滚时，根据指针回溯到对应版本数据即可，这里便不做详细介绍了。

![undo_log_1](/images/database/mvcc/undo_log_1.png)

## ReadView

undo log实现了多版本，但是要在事务中实现RR级别的隔离等级的重复读（RC级别也是同样的机制，只是在生成ReadView有所不同），就需要使用ReadView（快照）来实现。

在ReadView中有4个重要概念：

- m_ids: 在创建事务时，当下所有或活跃（即当前已开始但是还未结束的事务）的事务集合
- up_limit_id: 在所有m_ids中最小的事务id
- low_limit_id：在所有m_ids中最大事务的下一个id
- creator_trx_id：创建该ReadView的事务id

![readview_1](/images/database/mvcc/readview_1.png)

### 当前读

读取当前最新的已提交版本数据，读取时会对数据加锁，阻塞其他事务执行，获取新的ReadView。

一下操作会触发当前读：

- SELECT ... FOR SHARE
- SELECT ... FOR UPDATE
- INSERT
- UPDATE
- DELETE

更详细的信息请查看官方文档：[Locking Reads](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html)

### 快照读

指利用MVCC机制读取一个当前数据库快照ReadView，无论其他是否提交修改，当前事务都按照获取的快照版本来获取数据。一般来说不加锁的简单读都是快照读，根据数据库的隔离级别不同，获取快照的时机也不同。

## 实现

### Read committed

RC级别下，每次的快照读都会重新生成新的ReadView，所以会产生不可重复读的问题。

有如下事务，先启动A事务，再启动B事务：

![readview_2](/images/database/mvcc/readview_2.png)

1. A事务启动，生成一个新的undo log（DB_TRX_ID=61），假设，A事务将`money`修改为700，此时A事务尚未提交
2. B事务启动，B事务尝试读取`PK==1`记录中的`money`的值，重新生成新的快照，但是A事务尚未提交，所以在新的快照中，`DB_TRX_ID==61`任然是活跃事务，得到的值是600
3. A事务此时提交，`DB_TRX_ID==61`的事务不再活跃
4. B事务再次查询`money`的值，重新生成新的快照，此时`DB_TRX_ID==61`已经不活跃了，得到的结果所以700

### Repeatable read

RR级别下，快照只在事务启动的时候生成一次（事务中如果发生了当前读，会重新获取新的ReadView，事务的修改只在当前可见），后续都使用该快照读取数据，保证能够可重复读。

同样以上面RC的事务执行顺序，先启动A事务，再启动B事务：

1. A事务启动，生成一个新的undo log（DB_TRX_ID=61），假设，A事务将`money`修改为700，此时A事务尚未提交
2. B事务启动，B事务尝试读取`PK==1`记录中的`money`的值，得到的值是600，因为在B生成的ReadView中，`DB_TRX_ID==61`任处于活跃事务列表中，所以，获得`DB_TRX_ID==61`指向的上一条记录600
3. A事务此时提交，`DB_TRX_ID==61`的事务不再活跃
4. B事务再次查询`money`的值，得到的结果任然是600，因为RR级别下，ReadView只在事务启动的时候生成一次，所以此时在B事务的视角下，`DB_TRX_ID==61`事务任然是活跃事务

## 总结

数据库事务的隔离性（RC和RR，剩余两种隔离级别不涉及MVCC）实现依赖于MVCC机制，MVCC能够避免事务在查询数据时的加锁操作，提高性能。

RC级别下，会出现不可重复的读原因在于，每次快照读时，都会重新生成新的快照，当其他事务提交了修改后，就会导致同个事务中前后读取的数据不一致。

RR级别下，只在事务启动时，生成一次快照，所以，无论其他事务是否提交修改，都不会影响当前事务重复读取。